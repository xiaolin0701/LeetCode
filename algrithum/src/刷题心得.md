### 双指针
  - 题型 leetcode 26/27/80 移除数组中的数 392判断子序列 15三数之和
  - 快慢指针解法
  - 392判断子序列，注意边界值，即指针的移动不要让数组越界。判断条件需要考虑充分。15三数之和。需要把O(n3)的算法优化，利用数组的有序性以及跳过重复数组
### 快速幂
  - 题型 leetcode 113 求幂
  - 快速幂解法整体思想为分治，可以分为递归和迭代两种方式实现。两种方式思考角度不同，分别为等式由右向左、由左向右
  - 需要注意的是，数字的越界问题，迭代解法中使用到了移位来进行快速的乘除2操作
### KMP算法
  - 题型 leetcode 28 字符串匹配
  - [KMP详细讲解](https://www.zhihu.com/question/21923021/answer/281346746)
### 栈
  - 题型 leetcode 20 有效括号
  - 实现方式（在java中）
    - 初始化Deque（双端队列）的两个实现类ArrayDeque或LinkedList（线程不安全）
    - ArrayDeque是基于数组实现的。因此具有数组的快速访问随机元素，适配场景为高性能的双端队列
    - linkedList是基于链表实现的。它随机访问的性能较差。因为它找特定位置的元素需要进行遍历。但是插入或删除的效率很高，因为只需更新指针指向的结点无需重新分配内存
    - 在使用栈时的API: pop()弹出栈顶元素 push()压栈 peek()得到栈顶元素(不删除) isEmpty()判断是否空栈
### 动态规划
  - 题型
  -
### 哈希表
  - 题型 leetcode 49 字母异位词分组
  - HashMap相关API操作
    - put()放入键值对 get(key)根据键值对获取相应的值 getOrDefault(key, defaultValue)：根据键获取对应的值，如果键不存在，则返回默认值。values()：返回一个包含 HashMap 中所有值的 Collection 视图。
    - HashMap 的内部结构：
      - HashMap 内部使用了一个数组和链表或红黑树的组合来实现存储和查找。数组的每个元素称为桶（bucket），每个桶可以存储一个或多个键值对。 
      - 哈希函数： HashMap 使用哈希函数将键转换为数组索引。哈希函数可以将给定的键映射到数组的特定位置上。这个位置就是键值对在 HashMap 中的存储位置。 
      - 冲突处理： 由于不同的键可能会映射到相同的数组索引，这就是所谓的哈希冲突。HashMap 使用链表或红黑树来处理冲突。如果桶中的元素数量较少，HashMap 使用链表来存储键值对；当桶中的元素数量达到一定阈值时，HashMap 将链表转换为红黑树，以提高查找效率。 
      - 插入和查找操作： 
        - 插入操作：当要插入一个键值对时，HashMap 首先使用哈希函数计算键的哈希值，然后根据哈希值找到对应的桶。如果桶为空，则直接将键值对插入到桶中；如果桶中已经存在键值对，则根据键的比较结果进行更新或插入操作。 
        - 查找操作：当要查找一个键值对时，HashMap 使用哈希函数计算键的哈希值，然后根据哈希值找到对应的桶。如果桶为空，则表示没有找到对应的键值对；如果桶中有元素，则通过比较键的值来找到目标键值对。 
      - 扩容： 当 HashMap 中的元素数量达到一定的阈值时，为了保持较低的查找时间复杂度，HashMap 会自动进行扩容操作。扩容会重新调整数组的大小，并重新分配键值对到新的桶中。 
  - HashMap 的实现涉及到更多的细节，如负载因子、并发处理、迭代器等。Java 的 HashMap 实现是非线程安全的，如果在多线程环境中使用，可以考虑使用 ConcurrentHashMap。